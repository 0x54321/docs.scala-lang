
<!DOCTYPE html>
<html>
  <head>

    <title>SIP-22 - Async - Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">

    <!-- prettify js and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/prettify.css" type="text/css" />
    <script src="/resources/javascript/prettify/prettify.js" type="text/javascript" ></script>


    <!-- jquery js -->
    <script src="/resources/javascript/jquery.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.core.js" type="text/javascript" ></script>
    <script src="/resources/javascript/effects.highlight.js" type="text/javascript" ></script>
    <script src="/resources/javascript/moveScroller.js" type="text/javascript" ></script>

    <!-- Bootstrap JS and CSS -->
    <link rel="stylesheet" href="/resources/stylesheets/bootstrap.css" type="text/css" />
	  <script src="/resources/javascript/bootstrap-dropdown.js" type="text/javascript" ></script>
	  <script src="/resources/javascript/bootstrap-dropdown-app.js" type="text/javascript" ></script>

    <!-- Base stylesheet for all pages -->
    <link rel="stylesheet" href="/resources/stylesheets/base.css" type="text/css" />

    <!-- table of contents js -->
    <script src="/resources/javascript/toc.js" type="text/javascript" ></script>

    <!-- google analytics -->
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-574683-5']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>

    <!-- prettyprint js to prepend generated pre/code tags -->
    <script type="text/javascript">
      function styleCode()
        {
          if (typeof disableStyleCode != "undefined")
          {
              return;
          }
          var a = false;
          $("pre code").parent().each(function()
          {
              if (!$(this).hasClass("prettyprint"))
              {
                  $(this).addClass("prettyprint lang-scala linenums");
                  a = true
              }
          });
          if (a) { prettyPrint() }
      }
    </script>

    <script type="text/javascript">
      jQuery(document).ready(function($) {

            $(".scroll").click(function(event){
              event.preventDefault();
              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
              $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
            });
      });
    </script>

    <script type="text/javascript">
      $(window).ready(function goToSubsection() {
          if (window.location.hash)
          {
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top}, 500);
              $('html,body').animate({scrollTop:$(window.location.hash).offset().top-=50}, 500);
              $(window.location.hash).effect("highlight", {color: "#FFCC85"}, 3000);
          }
        });
    </script>

    <style type="text/css">

       p.contents {
           margin-left: 15px;
           font-weight: bold;
           font-size: 16px;
       }

       div#toc ul {
           list-style: none;
       }

       div#toc ul a {
           display: block;
           list-style: none;
           line-height: 22px;
           font-weight: bold;
           width: 100%;
       }

      div#toc ul li ul {
           list-style: disc;
      }

      div#toc ul li ul a {
           line-height: 18px;
           font-weight: normal;
      }

      div#toc ul li ul li ul {
           list-style: square;
      }
       div#toc ul li ul li ul a {
       }

       div#scroller-anchor {
           width: inherit;
       }

       div#scroller {
           width: inherit;
       }

       div#guide-title {
        text-transform: capitalize;
        font-size: 16px;
        padding-bottom: 6px;
        color: #BFBFBF;
        text-transform: uppercase;
        font-weight: bold;
       }

       input, textarea, select, .uneditable-input {
	       width: 165px;
	     }

    </style>

</head>
  <body onload="styleCode()">
    
    <!-- Topbar
    ================================================== -->
    <div class="topbar" >
      <div class="topbar-inner">
        <div class="container">
          <a class="brand" href="/sips/index.html"><img src="/resources/images/scala-logo.png"> Improvement Process</a>
          <ul class="nav">
           <li><a href="/sips/sip-submission.html">Submitting a new SIP</a></li>
           <li><a href="/sips/sip-list.html">SIP List</a></li>
           <li><a href="/sips/sip-tutorial.html">Tutorial: Writing a SIP</a></li>
           <li><a href="https://groups.google.com/forum/#!forum/scala-sips">Mailing List</a></li>
          </ul>
        </div>
      </div>
    </div>


<div class="container">
  <div class="row">    

    <div class="span12">
      <h1>SIP-22 - Async</h1>    
      <p><strong>By: Philipp Haller and Jason Zaugg</strong></p>

<h2 id='introduction'>Introduction</h2>

<p>This is a proposal to add constructs that simplify asynchronous and concurrent programming in Scala. The main constructs, async and await, are inspired by similar constructs introduced in C# 5.0. The main purpose of async/await is to make it possible to express efficient asynchronous code in a familiar direct style (where suspending operations look as if they were blocking). As a result, non-blocking code using Scala’s futures API [<a title='ScalaFutures' href='http://docs.scala-lang.org/overviews/core/futures.html'>1</a>] can be expressed without using higher-order functions, such as map and flatMap, or low-level callbacks.</p>

<p>On the level of types, async and await are methods with simple, intuitive types:</p>

<pre><code>def async[T](body: =&gt; T): Future[T]
def await[T](future: Future[T]): T</code></pre>

<p>Here, <code>Future[T]</code> refers to the <code>Future</code> trait in package <code>scala.concurrent</code>. (The system can be adapted to other implementations of future-like abstractions; at the moment the API with the required extension points is internal, though.) The above methods are used as follows:</p>

<pre><code>val fut = async {
  slowComputation()
}</code></pre>

<p>The async construct marks a block of asynchronous code, and returns a future. Depending on the execution context in the implicit scope (see [<a title='ScalaFutures' href='http://docs.scala-lang.org/overviews/core/futures.html'>1</a>]), the block of asynchronous code is either executed on the current thread or in a thread pool. The async block can contain calls to await:</p>

<pre><code>val futureDOY: Future[Response] =
  WS.url(&quot;http://api.day-of-year/today&quot;).get

val futureDaysLeft: Future[Response] =
  WS.url(&quot;http://api.days-left/today&quot;).get

val respFut = async {
  val dayOfYear = await(futureDOY).body
  val daysLeft = await(futureDaysLeft).body
  Ok(s&quot;$dayOfYear: $daysLeft days left!&quot;)
}</code></pre>

<p>Line 1 and 4 define two futures obtained as results of asynchronous requests to two hypothetical web services using an API inspired by Play Framework [<a title='Play' href='http://www.playframework.com/'>2</a>] (for the purpose of this example, the definition of type <code>Response</code> is unimportant). The <code>await</code> on line 8 causes the execution of the <code>async</code> block to suspend until <code>futureDOY</code> is completed (with a successful result or with an exception). When the future is completed successfully, its result is bound to the <code>dayOfYear</code> val, and the execution of the <code>async</code> block is resumed. When the future is completed with an exception (for example, because of a timeout), the invocation of <code>await</code> re-throws the exception that the future was completed with. In turn, this completes future respFut with the same exception. Likewise, the <code>await</code> on line 9 suspends the execution of the <code>async</code> block until futureDaysLeft is completed.</p>

<h2 id='comparison_with_scalas_futures_api'>Comparison with Scala’s Futures API</h2>

<p>The provided async and await constructs can significantly simplify code coordinating multiple futures. Consider the following example, written using Scala’s futures API together with for-comprehensions:</p>

<pre><code>def nameOfMonth(num: Int): Future[String] = ...
val date = “““(\d+)/(\d+)“““.r

for { doyResponse &lt;- futureDOY
      dayOfYear = doyResponse.body
      response &lt;- dayOfYear match {
        case date(month, day) =&gt;
          for (name &lt;- nameOfMonth(month.toInt))
          yield Ok(s“It’s $name!“)
        case _ =&gt;
          Future.successful(NotFound(“Not a...“))
      }
} yield response</code></pre>

<p>Line 1 defines an asynchronous method that converts an integer representing the number of a month to the name of the month (for example, the integer 2 is converted to &#8220;February&#8221;). Since the method is asynchronous, it returns a <code>Future[String]</code>. Line 2 defines a regular expression used to extract the month from a date string such as &#8220;07/24&#8221;. The for-comprehension starting on line 4 first awaits the result of <code>futureDOY</code> (the example re-uses the definition of <code>futureDOY</code> shown earlier). Scala&#8217;s futures provide methods like <code>map</code> and <code>flatMap</code>, and can thus be used as generators in for-comprehensions (for a more in-depth introduction of this feature see the official documentation [<a title='ScalaFutures' href='http://docs.scala-lang.org/overviews/core/futures.html'>1</a>]). The use of for-comprehensions can help make future-based code more clear, but in many cases it requires a significant amount of unnatural clutter and workarounds. The above example suffers from the following issues:</p>

<ul>
<li>To extract <code>dayOfYear</code>, we are forced to introduce the name <code>doyResponse</code>, a useless intermediate result (line 4);</li>

<li>to await the completion of the future returned by <code>nameOfMonth</code>, we are forced to use a nested for-comprehension (line 8);</li>

<li>the nested for-comprehension forces us to bind the result of nameOfMonth to name, a useless intermediate variable (line 8);</li>

<li>the nested for-comprehension forces us to introduce an artificial future that&#8217;s completed upon creation (line 11);</li>

<li>the artificial future introduces additional overhead and garbage (line 11);</li>

<li>finally, the use of for-yield might obscure the actual domain which is asynchronous computations with non-blocking awaits.</li>
</ul>

<p>The same example can be written using async/await as follows:</p>

<pre><code>async {
  await(futureDOY).body match {
    case date(month, day) =&gt;
      Ok(s“It’s ${await(nameOfMonth(month.toInt))}!“)
    case _ =&gt;
      NotFound(“Not a date, mate!“)
  }
}</code></pre>

<p>This version avoids all drawbacks of the previous version listed above. In addition, the generated code is more efficient, because it creates fewer closures.</p>

<h2 id='illegal_uses'>Illegal Uses</h2>

<p>The following uses of await are illegal and are reported as errors:</p>

<ul>
<li>await requires a directly-enclosing async; this means await must not be used inside a closure nested within an async block, or inside a nested object, trait, or class.</li>

<li>await must not be used inside an expression passed as an argument to a by-name parameter.</li>

<li>await must not be used inside a Boolean short-circuit argument.</li>

<li>return expressions are illegal inside an async block.</li>
</ul>

<h2 id='implementation'>Implementation</h2>

<p>We have implemented the present proposal using the macro system which has been introduced in Scala 2.10 as an experimental feature. Our implementation [<a title='ScalaAsync' href='https://github.com/scala/async'>3</a>] is targeted at Scala 2.11.0, but runs on using Scala 2.10.1 without any limitations.</p>

<h2 id='async_transform_specification'>Async Transform Specification</h2>

<p>In the following we consider the transformation of an invocation <code>async { &lt;block&gt; }</code> of the async macro. Before the block of code (<code>&lt;block&gt;</code>) is transformed, it is normalized into a form amenable to a transformation into a state machine. This form is called the &#8220;A-Normal Form&#8221; (ANF), and roughly means that:</p>

<ul>
<li><code>if</code>, <code>match</code>, and other control-flow constructs are only used as statements; they cannot be used as expressions;</li>

<li>calls to <code>await</code> are not allowed in compound expressions.</li>
</ul>

<p>After the ANF transform, the async macro prepares the state machine transformation by identifying vals, vars and defs that are accessed from multiple states. These will be lifted out to fields in the state machine object.</p>

<p>The next step of the transformation breaks the code into &#8220;chunks.&#8221; Each chunk contains a linear sequence of statements that concludes with a branching decision, or with the registration of a subsequent state handler as the continuation (the &#8220;on-completion handler&#8221;). Once all chunks have been built, the macro synthesizes a class representing the state machine. The class contains:</p>

<ul>
<li>an integer representing the current state ID</li>

<li>the lifted definitions</li>

<li>an <code>apply(value: Try[Any]): Unit</code> method that will be called on completion of each future. The behavior of this method is determined by the current state. It records the downcast result of the future in a field, and calls the <code>resume()</code> method.</li>

<li>the <code>resume(): Unit</code> method that switches on the current state and runs the users code for one &#8220;chunk,&#8221; and either: (a) registers the state machine as the handler for the next future, or (b) completes the result promise of the async block, if at the terminal state.</li>

<li>an <code>apply(): Unit</code> method that starts the evaluation of the async block&#8217;s body.</li>
</ul>

<h3 id='example'>Example</h3>

<pre><code>val future = async {                                     
  val f1 = async { true }                                 
  val x = 1                                               
  def inc(t: Int) = t + x                                 
  val t = 0                                               
  val f2 = async { 42 }                                   
  if (await(f1)) await(f2) else { val z = 1; inc(t + z) }
}</code></pre>

<p>After the ANF transform:</p>

<ul>
<li><code>await</code> calls are moved to only appear on the RHS of a value definition;</li>

<li><code>if</code> is no longer used as an expression; instead each branch writes its result to a synthetic var;</li>

<li>the <code>ExecutionContext</code> used to run the async block is obtained as an implicit argument.</li>
</ul>

<p>Follows the end result of the ANF transform (with very minor simplifications).</p>

<pre><code>{
  ();
  val f1: scala.concurrent.Future[Boolean] = {
    scala.concurrent.Future.apply[Boolean](true)(scala.concurrent.ExecutionContext.Implicits.global)
  };
  val x: Int = 1;
  def inc(t: Int): Int = t.+(x);
  val t: Int = 0;
  val f2: scala.concurrent.Future[Int] = {
    scala.concurrent.Future.apply[Int](42)(scala.concurrent.ExecutionContext.Implicits.global)
  };
  val await$1: Boolean = scala.async.Async.await[Boolean](f1);
  var ifres$1: Int = 0;
  if (await$1)
  {
    val await$2: Int = scala.async.Async.await[Int](f2);
    ifres$1 = await$2
  }
  else
  {
    ifres$1 = {
      val z: Int = 1;
      inc(t.+(z))
    }
  };
  ifres$1
}</code></pre>

<p>After the full async transform:</p>

<ul>
<li>
<p>one class is synthesized that represents the state machine. Its <code>apply()</code> method is used to start the computation (even the code before the first await call is executed asynchronously), and the <code>apply(tr: scala.util.Try[Any])</code> method will continue after each completed future that the async block awaits;</p>
</li>

<li>
<p>each chunk of code is moved into the a branch of the pattern match in <code>resume$async</code>;</p>
</li>

<li>
<p>value and function definitions accessed from multiple states are lifted to be members of class <code>stateMachine</code>; others remain local, e.g. <code>val z</code>;</p>
</li>

<li>
<p><code>result$async</code> holds the promise which is completed with the result of the async block;</p>
</li>

<li>
<p><code>execContext$async</code> holds the <code>ExecutionContext</code> that has been inferred.</p>
</li>
</ul>

<p>Follows the end result of the full async transform (with very minor simplifications).</p>

<pre><code>{
  class stateMachine$7 extends StateMachine[scala.concurrent.Promise[Int], scala.concurrent.ExecutionContext] {
    var state$async: Int = 0;
    val result$async: scala.concurrent.Promise[Int] = scala.concurrent.Promise.apply[Int]();
    val execContext$async = scala.concurrent.ExecutionContext.Implicits.global;
    var x$1: Int = 0;
    def inc$1(t: Int): Int = t.$plus(x$1);
    var t$1: Int = 0;
    var f2$1: scala.concurrent.Future[Int] = null;
    var await$1: Boolean = false;
    var ifres$1: Int = 0;
    var await$2: Int = 0;
    def resume$async(): Unit = try {
      state$async match {
        case 0 =&gt; {
          ();
          val f1 = {
            scala.concurrent.Future.apply[Boolean](true)(scala.concurrent.ExecutionContext.Implicits.global)
          };
          x$1 = 1;
          t$1 = 0;
          f2$1 = {
            scala.concurrent.Future.apply[Int](42)(scala.concurrent.ExecutionContext.Implicits.global)
          };
          f1.onComplete(this)(execContext$async)
        }
        case 1 =&gt; {
          ifres$1 = 0;
          if (await$1)
            {
              state$async = 2;
              resume$async()
            }
          else
            {
              state$async = 3;
              resume$async()
            }
        }
        case 2 =&gt; {
          f2$1.onComplete(this)(execContext$async);
          ()
        }
        case 5 =&gt; {
          ifres$1 = await$2;
          state$async = 4;
          resume$async()
        }
        case 3 =&gt; {
          ifres$1 = {
            val z = 1;
            inc$1(t$1.$plus(z))
          };
          state$async = 4;
          resume$async()
        }
        case 4 =&gt; {
          result$async.complete(scala.util.Success.apply(ifres$1));
          ()
        }
      }
    } catch {
      case NonFatal((tr @ _)) =&gt; {
        {
          result$async.complete(scala.util.Failure.apply(tr));
          ()
        };
        ()
      }
    };
    def apply(tr: scala.util.Try[Any]): Unit = state$async match {
      case 0 =&gt; {
        if (tr.isFailure)
          {
            result$async.complete(tr.asInstanceOf[scala.util.Try[Int]]);
            ()
          }
        else
          {
            await$1 = tr.get.asInstanceOf[Boolean];
            state$async = 1;
            resume$async()
          };
        ()
      }
      case 2 =&gt; {
        if (tr.isFailure)
          {
            result$async.complete(tr.asInstanceOf[scala.util.Try[Int]]);
            ()
          }
        else
          {
            await$2 = tr.get.asInstanceOf[Int];
            state$async = 5;
            resume$async()
          };
        ()
      }
    };
    def apply: Unit = resume$async()
  };
  val stateMachine$7: StateMachine[scala.concurrent.Promise[Int], scala.concurrent.ExecutionContext] = new stateMachine$7();
  scala.concurrent.Future.apply(stateMachine$7.apply())(scala.concurrent.ExecutionContext.Implicits.global);
  stateMachine$7.result$async.future
}</code></pre>

<h2 id='references'>References</h2>

<ol>
<li><a title='ScalaFutures' href='http://docs.scala-lang.org/overviews/core/futures.html'>The Scala Futures API</a></li>

<li><a title='Play' href='http://www.playframework.com/'>The Play! Framework</a></li>

<li><a title='ScalaAsync' href='https://github.com/scala/async'>Scala Async on Github</a></li>
</ol>
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  
    var disqus_shortname = 'scalasip'; // required: replace example with your forum shortname
  

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

    </div>
    
    <div class="span4">
      <div id="scroller-anchor">
  <div id="scroller">
    <p class="contents">Contents</p>
    <div id="toc"></div>    
              
  </div>
</div>

    </div>
  
  </div>
</div>

<div class="footer">
	<div class="container">
		<ul>
			<li><h5>API</h5></li>
			<li><a href="http://www.scala-lang.org/api/current/">Current</a></li>
			<li><a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html">Nightly</a></li>
		</ul>
		<ul>
			<li><h5>Learn</h5></li>
			<li><a href="/overviews">Guides & Overviews</a></li>
			<li><a href="/tutorials">Tutorials</a></li>
			<li><a href="/style">Scala Style Guide</a></li>				
		</ul>
		<ul>
			<li><h5>Quickref</h5></li>
			<li><a href="/glossary">Glossary</a></li>
			<li><a href="/cheatsheets">Cheatsheets</a></li>
		</ul>
		<ul>
			<li><h5>Contribute</h5></li>
			<li><a href="http://github.com/scala/scala.github.com">Source Code</a></li>
			<li><a href="/contribute.html">Contributors Guide</a></li>
			<li><a href="http://getsatisfaction.com/scaladocs">Suggestions</a></li>			
		</ul>
		<ul>
			<li><h5>Other Resources</h5></li>
			<li><a href="http://wiki.scala-lang.org">Wiki</a></li>
			<li><a href="/sips">Scala Improvement Process</a></li>				
		</ul>						
	</div>
	<div class="container copyright">
 		<p>
			Copyright &copy; 2011-2013 EPFL. All rights reserved.
			<a href="https://github.com/scala/scala.github.com/commits/gh-pages.atom"><img align="right" height="20px" width="20px" src="/resources/images/rss.png" alt="RSS feed of updates to the github repo hosting this site"></a>
		</p>		
	</div>
</div>


<script type="text/javascript">
  $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>

<script type="text/javascript">
  $(function() {
    moveScroller();
  });
</script>

  </body>
</html>

    